Subject: [PATCH] Fixish Rounded Outline rendering, fix self skill issue
---
Index: src/main/java/com/h1ggsk/radon/gui/components/StringBox.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/h1ggsk/radon/gui/components/StringBox.java b/src/main/java/com/h1ggsk/radon/gui/components/StringBox.java
--- a/src/main/java/com/h1ggsk/radon/gui/components/StringBox.java	(revision 704e56c39110ddc6aa894d755af5982ec1831e93)
+++ b/src/main/java/com/h1ggsk/radon/gui/components/StringBox.java	(date 1754972387876)
@@ -59,14 +59,14 @@
         final int a2 = MathUtil.clampInt(TextRenderer.getWidth(this.content) + 80, 600, this.this$0.mc.getWindow().getWidth() - 100);
         final int n4 = (width2 - a2) / 2;
         final int n5 = (height2 - 120) / 2;
-        RenderUtils.renderRoundedQuad(drawContext.getMatrices(), new Color(30, 30, 35, 240), n4, n5, n4 + a2, n5 + 120, 8.0, 8.0, 8.0, 8.0, 20.0);
-        RenderUtils.renderRoundedQuad(drawContext.getMatrices(), new Color(40, 40, 45, 255), n4, n5, n4 + a2, n5 + 30, 8.0, 8.0, 0.0, 0.0, 20.0);
+        RenderUtils.renderRoundedQuad(drawContext, new Color(30, 30, 35, 240), n4, n5, n4 + a2, n5 + 120, 8.0, 8.0, 8.0, 8.0, 20.0);
+        RenderUtils.renderRoundedQuad(drawContext, new Color(40, 40, 45, 255), n4, n5, n4 + a2, n5 + 30, 8.0, 8.0, 0.0, 0.0, 20.0);
         drawContext.fill(n4, n5 + 30, n4 + a2, n5 + 31, Utils.getMainColor(255, 1).getRGB());
         TextRenderer.drawCenteredString(this.setting.getName(), drawContext, n4 + a2 / 2, n5 + 8, new Color(245, 245, 245, 255).getRGB());
         final int n6 = n4 + 20;
         final int n7 = n5 + 50;
         final int n8 = a2 - 40;
-        RenderUtils.renderRoundedQuad(drawContext.getMatrices(), new Color(20, 20, 25, 255), n6, n7, n6 + n8, n7 + 30, 5.0, 5.0, 5.0, 5.0, 20.0);
+        RenderUtils.renderRoundedQuad(drawContext, new Color(20, 20, 25, 255), n6, n7, n6 + n8, n7 + 30, 5.0, 5.0, 5.0, 5.0, 20.0);
         RenderUtils.renderRoundedOutline(drawContext, new Color(60, 60, 65, 255), n6, n7, n6 + n8, n7 + 30, 5.0, 5.0, 5.0, 5.0, 1.0, 20.0);
         final String content = this.content;
         final int n9 = n6 + 10;
@@ -95,9 +95,9 @@
         final int n12 = n5 + 120 - 30;
         final int n13 = n4 + a2 - 80 - 20;
         final int n14 = n13 - 80 - 10;
-        RenderUtils.renderRoundedQuad(drawContext.getMatrices(), Utils.getMainColor(255, 1), n13, n12, n13 + 80, n12 + 25, 5.0, 5.0, 5.0, 5.0, 20.0);
+        RenderUtils.renderRoundedQuad(drawContext, Utils.getMainColor(255, 1), n13, n12, n13 + 80, n12 + 25, 5.0, 5.0, 5.0, 5.0, 20.0);
         TextRenderer.drawCenteredString("Save", drawContext, n13 + 40, n12 + 6, new Color(245, 245, 245, 255).getRGB());
-        RenderUtils.renderRoundedQuad(drawContext.getMatrices(), new Color(60, 60, 65, 255), n14, n12, n14 + 80, n12 + 25, 5.0, 5.0, 5.0, 5.0, 20.0);
+        RenderUtils.renderRoundedQuad(drawContext, new Color(60, 60, 65, 255), n14, n12, n14 + 80, n12 + 25, 5.0, 5.0, 5.0, 5.0, 20.0);
         TextRenderer.drawCenteredString("Cancel", drawContext, n14 + 40, n12 + 6, new Color(245, 245, 245, 255).getRGB());
         TextRenderer.drawString("Press Escape to save and close", drawContext, n4 + 20, n5 + 120 - 20, new Color(150, 150, 150, 200).getRGB());
         RenderUtils.scaledProjection();
Index: src/main/java/com/h1ggsk/radon/utils/state/RenderStates.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/h1ggsk/radon/utils/state/RenderStates.java b/src/main/java/com/h1ggsk/radon/utils/state/RenderStates.java
--- a/src/main/java/com/h1ggsk/radon/utils/state/RenderStates.java	(revision 704e56c39110ddc6aa894d755af5982ec1831e93)
+++ b/src/main/java/com/h1ggsk/radon/utils/state/RenderStates.java	(date 1754972263551)
@@ -9,5 +9,6 @@
     public static void init() {
         CircleRenderState.init();
         RoundedQuadRenderState.init();
+        RoundedOutlineRenderState.init();
     }
 }
Index: src/main/java/com/h1ggsk/radon/utils/state/RoundedOutlineRenderState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/h1ggsk/radon/utils/state/RoundedOutlineRenderState.java b/src/main/java/com/h1ggsk/radon/utils/state/RoundedOutlineRenderState.java
new file mode 100644
--- /dev/null	(date 1754972263558)
+++ b/src/main/java/com/h1ggsk/radon/utils/state/RoundedOutlineRenderState.java	(date 1754972263558)
@@ -0,0 +1,141 @@
+package com.h1ggsk.radon.utils.state;
+
+import com.mojang.blaze3d.pipeline.BlendFunction;
+import com.mojang.blaze3d.pipeline.RenderPipeline;
+import com.mojang.blaze3d.platform.DestFactor;
+import com.mojang.blaze3d.platform.SourceFactor;
+import com.mojang.blaze3d.vertex.VertexFormat;
+import net.minecraft.client.gl.RenderPipelines;
+import net.minecraft.client.gui.ScreenRect;
+import net.minecraft.client.gui.render.state.SimpleGuiElementRenderState;
+import net.minecraft.client.render.VertexConsumer;
+import net.minecraft.client.render.VertexFormats;
+import net.minecraft.client.texture.TextureSetup;
+import net.minecraft.util.Identifier;
+import org.jetbrains.annotations.Nullable;
+import org.joml.Matrix3x2f;
+import org.joml.Matrix3x2fStack;
+
+import java.awt.Color;
+
+import static net.minecraft.client.gl.RenderPipelines.register;
+
+/**
+ * Technically broken, should render a rounded outline around the given rect.
+ * FIXME!!!
+ */
+public record RoundedOutlineRenderState(Matrix3x2f matrices, ScreenRect scissorArea, ScreenRect bounds, Color color, double x1, double y1, double x2, double y2, double radius1, double radius2, double radius3, double radius4, double maybeOffset, double resolution) implements SimpleGuiElementRenderState {
+    private static final RenderPipeline PIPELINE = register(
+            RenderPipeline.builder(RenderPipelines.GUI_SNIPPET)
+                    .withLocation(Identifier.of("radon", "rounded_quad_outline"))
+                    .withBlend(new BlendFunction(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ZERO))
+                    .withVertexFormat(VertexFormats.POSITION_COLOR, VertexFormat.DrawMode.TRIANGLE_FAN)
+                    .build()
+    );
+
+    public RoundedOutlineRenderState(Matrix3x2fStack matrices, ScreenRect scissorArea, ScreenRect bounds, Color color, double x1, double y1, double x2, double y2, double radius1, double radius2, double radius3, double radius4, double maybeOffset, double resolution) {
+        this(new Matrix3x2f(matrices), scissorArea, bounds, color, x1, y1, x2, y2, radius1, radius2, radius3, radius4, maybeOffset, resolution);
+    }
+
+    public RoundedOutlineRenderState(Matrix3x2f matrices, ScreenRect scissorArea, Color color, double x1, double y1, double x2, double y2, double radius1, double radius2, double radius3, double radius4, double maybeOffset, double resolution) {
+        this(matrices, scissorArea, createBounds((int) x1, (int) y1, (int) x2, (int) y2, matrices, scissorArea), color, x1, y1, x2, y2, radius1, radius2, radius3, radius4, maybeOffset, resolution);
+    }
+
+    public RoundedOutlineRenderState(Matrix3x2fStack matrices, ScreenRect scissorArea, Color color, double x1, double y1, double x2, double y2, double radius1, double radius2, double radius3, double radius4, double maybeOffset, double resolution) {
+        this(new Matrix3x2f(matrices), scissorArea, createBounds((int) x1, (int) y1, (int) x2, (int) y2, matrices, scissorArea), color, x1, y1, x2, y2, radius1, radius2, radius3, radius4, maybeOffset, resolution);
+    }
+
+    public RoundedOutlineRenderState(Matrix3x2fStack matrices, ScreenRect scissorArea, Color color, double x1, double y1, double x2, double y2, double radius, double maybeOffset, double resolution) {
+        this(new Matrix3x2f(matrices), scissorArea, createBounds((int) x1, (int) y1, (int) x2, (int) y2, matrices, scissorArea), color, x1, y1, x2, y2, radius, radius, radius, radius, maybeOffset, resolution);
+    }
+
+    @Override
+    public void setupVertices(VertexConsumer vertices, float depth) {
+        final float r = (float) color.getRed() / 255.0f;
+        final float g = (float) color.getGreen() / 255.0f;
+        final float b = (float) color.getBlue() / 255.0f;
+        final float a = (float) color.getAlpha() / 255.0f;
+        // {xish: double, yish: double, radius: double}[]
+        final double[][] array = new double[][]{
+                new double[]{x2 - radius4, y2 - radius4, radius4},
+                new double[]{x2 - radius2, y1 + radius2, radius2},
+                new double[]{x1 + radius1, y1 + radius1, radius1},
+                new double[]{x1 + radius3, y2 - radius3, radius3}
+        };
+        for (int i = 0; i < 4; ++i) {
+            final double[] maybeOffsets = array[i];
+            final double radius = maybeOffsets[2];
+            for (double angdeg = i * 90.0; angdeg < 90.0 + i * 90.0; angdeg += 90.0 / resolution) {
+                final double radians = Math.toRadians(angdeg);
+                final double sin = Math.sin((float) radians);
+                final double relativeX = sin * radius;
+                final double cos = Math.cos((float) radians);
+                final double relativeY = cos * radius;
+                vertices.vertex(
+                        matrices,
+                        (float) maybeOffsets[0] + (float) relativeX,
+                        (float) maybeOffsets[1] + (float) relativeY,
+                        depth
+                ).color(r, g, b, a);
+                vertices.vertex(
+                        matrices,
+                        (float) (maybeOffsets[0] + (float) relativeX + sin * maybeOffset),
+                        (float) (maybeOffsets[1] + (float) relativeY + cos * maybeOffset),
+                        depth
+                ).color(r, g, b, a);
+            }
+            final double radians = Math.toRadians(90.0 + i * 90.0);
+            final double sin2 = Math.sin((float) radians);
+            final double relativeX = sin2 * radius;
+            final double cos2 = Math.cos((float) radians);
+            final double relativeY = cos2 * radius;
+            vertices.vertex(
+                    matrices,
+                    (float) maybeOffsets[0] + (float) relativeX,
+                    (float) maybeOffsets[1] + (float) relativeY,
+                    depth
+            ).color(r, g, b, a);
+            vertices.vertex(
+                    matrices,
+                    (float) (maybeOffsets[0] + (float) relativeX + sin2 * maybeOffset),
+                    (float) (maybeOffsets[1] + (float) relativeY + cos2 * maybeOffset),
+                    depth
+            ).color(r, g, b, a);
+        }
+        final double[] maybeOffsets = array[0];
+        final double radius = maybeOffsets[2];
+        vertices.vertex(
+                matrices,
+                (float) maybeOffsets[0],
+                (float) maybeOffsets[1] + (float) radius,
+                depth
+        ).color(r, g, b, a);
+        vertices.vertex(
+                matrices,
+                (float) maybeOffsets[0],
+                (float) (maybeOffsets[1] + (float) radius + maybeOffset),
+                depth
+        ).color(r, g, b, a);
+    }
+
+    @Override
+    public RenderPipeline pipeline() {
+        return PIPELINE;
+    }
+
+    @Override
+    public TextureSetup textureSetup() {
+        return TextureSetup.empty();
+    }
+
+    @Nullable
+    private static ScreenRect createBounds(int x1, int y1, int x2, int y2, Matrix3x2f pose, @Nullable ScreenRect scissorArea) {
+        ScreenRect screenRect = new ScreenRect(x1, y1, x2 - x1, y2 - y1).transformEachVertex(pose);
+        return scissorArea != null
+               ? scissorArea.intersection(screenRect)
+               : screenRect;
+    }
+
+    public static void init() {
+    }
+}
Index: src/main/java/com/h1ggsk/radon/utils/RenderUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/h1ggsk/radon/utils/RenderUtils.java b/src/main/java/com/h1ggsk/radon/utils/RenderUtils.java
--- a/src/main/java/com/h1ggsk/radon/utils/RenderUtils.java	(revision 704e56c39110ddc6aa894d755af5982ec1831e93)
+++ b/src/main/java/com/h1ggsk/radon/utils/RenderUtils.java	(date 1754972263546)
@@ -2,6 +2,7 @@
 
 import com.h1ggsk.radon.Radon;
 import com.h1ggsk.radon.utils.state.CircleRenderState;
+import com.h1ggsk.radon.utils.state.RoundedOutlineRenderState;
 import com.h1ggsk.radon.utils.state.RoundedQuadRenderState;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.blaze3d.systems.VertexSorter;
@@ -92,38 +93,12 @@
         RenderSystem.disableBlend();
     }
 
-    public static void renderRoundedOutlineInternal(final Matrix4f matrix4f, final float n, final float n2, final float n3, final float n4, final double n5, final double n6, final double n7, final double n8, final double n9, final double n10, final double n11, final double n12, final double n13, final double n14) {
-        final BufferBuilder begin = Tessellator.getInstance().begin(VertexFormat.DrawMode.TRIANGLE_STRIP, VertexFormats.POSITION_COLOR);
-        final double[][] array = new double[4][];
-        array[0] = new double[]{n7 - n12, n8 - n12, n12};
-        array[1] = new double[]{n7 - n10, n6 + n10, n10};
-        array[2] = new double[]{n5 + n9, n6 + n9, n9};
-        array[3] = new double[]{n5 + n11, n8 - n11, n11};
-        for (int i = 0; i < 4; ++i) {
-            final double[] array2 = array[i];
-            final double n15 = array2[2];
-            for (double angdeg = i * 90.0; angdeg < 90.0 + i * 90.0; angdeg += 90.0 / n14) {
-                final double radians = Math.toRadians(angdeg);
-                final double sin = Math.sin((float) radians);
-                final double n16 = sin * n15;
-                final double cos = Math.cos((float) radians);
-                final double n17 = cos * n15;
-                begin.vertex(matrix4f, (float) array2[0] + (float) n16, (float) array2[1] + (float) n17, 0.0f).color(n, n2, n3, n4);
-                begin.vertex(matrix4f, (float) (array2[0] + (float) n16 + sin * n13), (float) (array2[1] + (float) n17 + cos * n13), 0.0f).color(n, n2, n3, n4);
-            }
-            final double radians2 = Math.toRadians(90.0 + i * 90.0);
-            final double sin2 = Math.sin((float) radians2);
-            final double n18 = sin2 * n15;
-            final double cos2 = Math.cos((float) radians2);
-            final double n19 = cos2 * n15;
-            begin.vertex(matrix4f, (float) array2[0] + (float) n18, (float) array2[1] + (float) n19, 0.0f).color(n, n2, n3, n4);
-            begin.vertex(matrix4f, (float) (array2[0] + (float) n18 + sin2 * n13), (float) (array2[1] + (float) n19 + cos2 * n13), 0.0f).color(n, n2, n3, n4);
-        }
-        final double[] array3 = array[0];
-        final double n20 = array3[2];
-        begin.vertex(matrix4f, (float) array3[0], (float) array3[1] + (float) n20, 0.0f).color(n, n2, n3, n4);
-        begin.vertex(matrix4f, (float) array3[0], (float) (array3[1] + (float) n20 + n13), 0.0f).color(n, n2, n3, n4);
-        BufferRenderer.drawWithGlobalProgram(begin.end());
+    /**
+     * very broken
+     * FIXME!!!!!
+     */
+    public static void renderRoundedOutline(final DrawContext drawContext, final Color color, final double n, final double n2, final double n3, final double n4, final double n5, final double n6, final double n7, final double n8, final double n9, final double n10) {
+        drawContext.state.addSimpleElement(new RoundedOutlineRenderState(drawContext.getMatrices(), drawContext.scissorStack.peekLast(), color, n, n2, n3, n4, n5, n6, n7, n8, n9, n10));
     }
 
     public static void setScissorRegion(final int n, final int n2, final int n3, final int n4) {
@@ -166,15 +141,6 @@
         RenderSystem.disableBlend();
     }
 
-    public static void renderRoundedOutline(final DrawContext drawContext, final Color color, final double n, final double n2, final double n3, final double n4, final double n5, final double n6, final double n7, final double n8, final double n9, final double n10) {
-        final int rgb = color.getRGB();
-        final Matrix4f positionMatrix = drawContext.getMatrices().peek().getPositionMatrix();
-        setup();
-        RenderSystem.setShader((Supplier) GameRenderer::getPositionColorProgram);
-        renderRoundedOutlineInternal(positionMatrix, (rgb >> 16 & 0xFF) / 255.0f, (rgb >> 8 & 0xFF) / 255.0f, (rgb & 0xFF) / 255.0f, (rgb >> 24 & 0xFF) / 255.0f, n, n2, n3, n4, n5, n6, n7, n8, n9, n10);
-        cleanup();
-    }
-
     public static MatrixStack matrixFrom(final double n, final double n2, final double n3) {
         final MatrixStack matrixStack = new MatrixStack();
         final Camera camera = MinecraftClient.getInstance().gameRenderer.getCamera();
@@ -281,7 +247,7 @@
         final Matrix3x2fStack matrices = drawContext.getMatrices();
         matrices.pushMatrix();
         matrices.translate((float) n, (float) n2, (float) n4);
-        matrices.scale(n5, n5, 1.0f);
+        matrices.scale(n5, n5);
         drawContext.drawItem(itemStack, 0, 0);
         matrices.popMatrix();
     }
